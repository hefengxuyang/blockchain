# 简介

## 区块链模型
1） UTXO模型 UTXO(Unspent Transaction Output),即未花费的交易输出。例如比特币系统中，每一笔交易花费的输出（outputs）都是之前的交易产生的，而这笔交易的输出（outputs）将会在未来的某一笔交易中花费出去，这种模型便称为UTXO模型。用户的钱包跟踪与用户拥有的所有地址相关联的未花费的交易的列表，并且钱包的余额被计算为那些未花费的交易的总和。UTXO模型跟现实生活中的现金模型相似。
  - 交易并行程度高，可扩展性强
  - 隐私性高
  - 无状态
  - 区块比较轻量

2）账户模型 账户(account-based)模型，账户余额作为一个世界状态的形式存在。例如在以太坊系统中，账户保存了与它相关交易的余额的世界状态，在每一币笔交易发出之前都需要检查帐户余额以确保其大于或等于支出交易金额。账户模型跟现实生活中银行卡/支付宝/微信等账户的模型相似，所以用户理解起来也相对比较容易。
  - 交易并行程度低，双花攻击的频率高
  - 操作简便，通过智能合约可以实现各种应用
  - 有状态
  - 保存所有账户状态信息，区块数据量大
  - 验证交易效率高

3）DAG模型 DAG(Directed Acyclic Graph),即有向无环图
  - 交易并行程度大
  - 不保存系统的全局状态

## 智能合约简介
  智能合约是一种旨在以数字化的方式让验证和执行合约的谈判或履行更加便捷的计算机协议。智能合约可以在没有第三方信任机构的情况下执行可信交易，并且这些交易具有可追踪性和不可逆转性。

  智能合约可以根据已有的指令集实现各种各样的功能，但是由于区块链系统的差别，它们的指令集和存储模式是不一样的，如果要实现相同的功能，它们的智能合约形式差异会比较大。

  UTXO模型合约和账户模型合约的区别：

  1、OP指令能否访问交易中的数据，OP指令能够访问context的内容和其他相关外部存储参数的指令结构决定了智能合约应用的广度。虽然UTXO模型也可以构造一些可以访问交易中的数据OP指令，但是缺少账户模型的世界状态，构造应用类型的智能合约还是存在一定的难度。

  2、是否存储状态，即接收对象是否一直“存活”。UTXO模型是无状态的，如果一个接收脚本（script）被解锁，那么这个脚本将不再存活;而以太坊的账户模型是有状态的，合约的状态数据可以累积存储在链上的存储空间中，直至合约被销毁，存储空间才会被释放掉。
  
  例如一个抛硬币的合约，所有人都可以参与竞猜硬币落地的结果，如果结果为“正面”，那么将竞猜为“反面”的人的钱平均分配给投注正确的人，这个合约是一个典型的多方参与的竞猜游戏。
  
  - 对于以太坊的账户模型而言，这个合约很容易实现，用户创建一个抛硬币的合约部署到链上，然后对外暴露的是一个一直“存活”的地址，所有人都可以通过调用该合约的函数参与竞猜，所有参与者的竞猜状态将会被保存在合约的存储空间中，只要设定一个特定的截止时间并将实际的结果从外部传入进去，那么合约将会自动执行竞猜结果的分配工作。以太坊合约的实现基本功能代码如下：（不包含初始化、充值和提现等操作）
  ```js
  function flip(bool heads) public payable {
    require(msg.value * 2 <= address(this).balance);
    if ((block.blockhash(block.number - 1) % 2 == 0 && heads ||block.blockhash(block.number - 1) % 2 == 1 && ! heads){
        msg.sender.transfer(msg.value * 2);
    }
  }
  ```

  - 对于比特币的UTXO模型而言，多人参与的抛硬币合约就比较难实现了，因为合约对象是一个无状态的脚本（script）。为了保持合约“存活”状态，一种方式是玩家每次调用合约之后都需要创建新的合约脚本来维持已经参与过的玩家的状态，另一种方式是合约需要保存很多重复的逻辑来保证每个玩家都能参与游戏。很显然，要实现这个合约不论哪一种方式都有一定的难度。对于上述抛硬币游戏而言，实现这个智能合约需要突破的两点为：

      1）适应任意大小的投注
      
      2）复制合约本身来确保UTXO不能被一个人使用（其实就是构造多个合约UTXO）

  上述两个特征已经表明UTXO模型的区块链系统不太适合这样的应用场景。

  UTXO模型的合约也有适合的场景，例如多签合约。如果用账户模型的以太坊来实现这种合约[MultiSigWallet.sol](https://github.com/gnosis/MultiSigWallet/blob/master/contracts/MultiSigWallet.sol)，其复杂度也是非常高的。

  我们还可以实现基于UTXO模型的多签（multisigs）托管服务。甲方试图从乙方购买商品，并将该商品的价格锁定为与甲方、乙方和托管主持人C签订的托管合同（3个中的2个）。A和B（买方和卖方）可以同意将资金转移到他们自己（并且不必支付托管费），或者如果其中一方没有合作，他们中的一方可以援引C的帮助。

  不论UTXO模型还是账户模型的区块链系统，智能合约能够实现什么样的应用，其本质取决于OP指令集及其数据存储问题，而指令集是实现智能合约的功能集的基础。




